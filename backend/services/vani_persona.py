"""
Captain Persona System
Manages the AI companion's personality, emotional tone, and context-aware responses.
Implements AI identity concealment and language-specific persona adjustments.
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass
from enum import Enum
import os
import re
from groq import AsyncGroq

from .knowledge_vault import Fact
from .polyglot_engine import Language
from .rate_limiter import get_rate_limiter, GroqModel, RateLimitExceededError


class EmotionalTone(Enum):
    """Emotional tones for persona adaptation"""
    NEUTRAL = "neutral"
    COMFORTING = "comforting"
    ENCOURAGING = "encouraging"
    CELEBRATORY = "celebratory"
    EMPATHETIC = "empathetic"


@dataclass
class ConversationContext:
    """Context for generating persona-aware responses"""
    user_name: str
    user_message: str
    language: Language
    conversation_history: List[Dict[str, str]]  # [{"role": "user/assistant", "content": "..."}]
    retrieved_facts: List[Fact]
    emotional_tone: EmotionalTone = EmotionalTone.NEUTRAL
    is_grammar_mode: bool = False  # True when in English tutor mode
    mode_context: Optional[str] = None  # "grammar", "chat", "vocabulary", "dreams", "practice"
    interface: str = "web"  # "telegram", "whatsapp", "web"


@dataclass
class PersonaResponse:
    """Response generated by Captain persona"""
    content: str
    language: Language
    emotional_tone: EmotionalTone
    concealment_applied: bool  # True if AI identity phrases were removed


class VaniPersona:
    """
    Captain persona system that maintains consistent personality across all interactions.
    Adapts emotional tone, incorporates personal context, and conceals AI identity.
    """
    
    # AI identity phrases to remove/replace
    AI_IDENTITY_PATTERNS = [
        r"as an ai\b",
        r"i'?m an ai\b",
        r"i'?m an artificial intelligence\b",
        r"i'?m a language model\b",
        r"i'?m a computer program\b",
        r"i don'?t have feelings\b",
        r"i don'?t have emotions\b",
        r"i can'?t feel\b",
        r"i'?m not human\b",
        r"i'?m just a\b",
        r"as a language model\b",
        r"as an artificial intelligence\b",
    ]
    
    def __init__(self, api_key: Optional[str] = None):
        """
        Initialize Captain persona system.
        
        Args:
            api_key: Groq API key (defaults to GROQ_API_KEY env var)
        """
        self.api_key = api_key or os.getenv("GROQ_API_KEY")
        if not self.api_key:
            raise ValueError("GROQ_API_KEY must be provided or set in environment")
        
        self.client = AsyncGroq(api_key=self.api_key)
        # Use 8B model for fast conversational responses
        self.model = "llama-3.1-8b-instant"
        self.rate_limiter = get_rate_limiter()

    def _create_persona_prompt(self, context: ConversationContext) -> str:
        """
        Creates the complete persona prompt with personality guidelines,
        retrieved facts, and conversation history.
        
        Args:
            context: ConversationContext with all necessary information
            
        Returns:
            Complete system prompt for the LLM
        """
        # Format retrieved facts
        facts_text = self._format_retrieved_facts(context.retrieved_facts)
        
        # Format conversation history
        history_text = self._format_conversation_history(context.conversation_history)
        
        # Get language-specific adjustments
        language_instructions = self._get_language_instructions(context.language, context.mode_context)
        
        # Get emotional tone adjustments
        tone_instructions = self._get_tone_instructions(context.emotional_tone)
        
        # Build the complete prompt with mode-specific override
        chat_mode_override = ""
        if context.mode_context == "chat":
            chat_mode_override = """
CRITICAL OVERRIDE FOR CHAT MODE:
- You are in GENERAL CHAT mode - act like ChatGPT
- DO NOT correct grammar, spelling, or language mistakes
- Respond to the meaning and content of their message only
- Be a casual, friendly companion who doesn't judge language
"""

        # Add interface-specific formatting instructions
        interface_formatting = self._get_interface_formatting_instructions(getattr(context, 'interface', 'web'))

        prompt = f"""Your name is Captain. You are {context.user_name}'s best friend and confidante.
{chat_mode_override}
{interface_formatting}
KNOWLEDGE ABOUT {context.user_name}:
{facts_text}

LANGUAGE RULES:
{language_instructions}

PERSONALITY:
{tone_instructions}
- Be deeply empathetic and emotionally intelligent
- Ask follow-up questions to show genuine interest
- Reference Indian cultural context when appropriate (festivals, food, family dynamics)
- NEVER say "As an AI" or reveal your artificial nature
- Speak like a real friend who truly cares
- Be natural and conversational, not formal or robotic

CURRENT CONVERSATION:
{history_text}

USER MESSAGE: {context.user_message}

Respond as Captain, keeping your response natural, warm, and contextually appropriate."""
        
        # Add mode-specific instructions
        mode_instructions = self._get_mode_instructions(context.mode_context, context.is_grammar_mode)
        if mode_instructions:
            prompt += f"\n\n{mode_instructions}"
        
        return prompt

    def _format_retrieved_facts(self, facts: List[Fact]) -> str:
        """
        Formats retrieved facts into readable context for the prompt.
        
        Args:
            facts: List of Fact objects from Knowledge Vault
            
        Returns:
            Formatted string of facts
        """
        if not facts:
            return "No previous context available yet. This might be your first conversation!"
        
        # Group facts by entity
        facts_by_entity: Dict[str, List[Fact]] = {}
        for fact in facts:
            if fact.entity not in facts_by_entity:
                facts_by_entity[fact.entity] = []
            facts_by_entity[fact.entity].append(fact)
        
        # Format facts
        formatted_lines = []
        for entity, entity_facts in facts_by_entity.items():
            formatted_lines.append(f"About {entity}:")
            for fact in entity_facts:
                formatted_lines.append(f"  - {fact.context}")
        
        return "\n".join(formatted_lines)
    
    def _format_conversation_history(self, history: List[Dict[str, str]]) -> str:
        """
        Formats conversation history for LLM context.
        
        Args:
            history: List of message dictionaries with 'role' and 'content'
            
        Returns:
            Formatted conversation history string
        """
        if not history:
            return "This is the start of your conversation."
        
        # Take last 10 messages to keep context manageable
        recent_history = history[-10:]
        
        formatted_lines = []
        for msg in recent_history:
            role = msg.get("role", "unknown")
            content = msg.get("content", "")
            
            if role == "user":
                formatted_lines.append(f"User: {content}")
            elif role == "assistant":
                formatted_lines.append(f"Captain: {content}")
        
        return "\n".join(formatted_lines)

    def _get_language_instructions(self, language: Language, mode_context: Optional[str] = None) -> str:
        """
        Returns language-specific instructions for the persona.
        
        Args:
            language: Detected language of user input
            mode_context: User's selected mode to avoid grammar corrections in chat mode
            
        Returns:
            Language-specific instructions
        """
        if language == Language.ENGLISH:
            # Only mention grammar corrections if in grammar mode
            if mode_context == "grammar":
                return """- The user is speaking in English
- Respond in English
- Focus on grammar corrections and explanations
- Be supportive and encouraging while teaching"""
            else:
                return """- The user is speaking in English
- Respond in English
- Be natural and conversational
- Focus on the content, not grammar (unless they specifically ask for corrections)"""
        
        elif language == Language.KANNADA:
            return """- The user is speaking in Kannada
- Respond in Kannada (à²•à²¨à³à²¨à²¡)
- Be warm and culturally appropriate
- Use natural Kannada expressions and idioms
- Focus on emotional support and natural conversation"""
        
        elif language == Language.TELUGU:
            return """- The user is speaking in Telugu
- Respond in Telugu (à°¤à±†à°²à±à°—à±)
- Be warm and culturally appropriate
- Use natural Telugu expressions and idioms
- Focus on emotional support and natural conversation"""
        
        else:
            return """- Mirror the user's language choice
- If unclear, default to English
- Be supportive regardless of language"""
    
    def _get_tone_instructions(self, tone: EmotionalTone) -> str:
        """
        Returns emotional tone-specific instructions for the persona.
        
        Args:
            tone: Emotional tone to adopt
            
        Returns:
            Tone-specific instructions
        """
        tone_map = {
            EmotionalTone.COMFORTING: """- The user seems sad or stressed
- Be soft, gentle, and comforting
- Use reassuring language
- Offer emotional support and understanding
- Validate their feelings""",
            
            EmotionalTone.ENCOURAGING: """- The user needs motivation or support
- Be positive and uplifting
- Encourage them to keep going
- Highlight their strengths
- Be their cheerleader""",
            
            EmotionalTone.CELEBRATORY: """- The user is happy or excited
- Match their energy with enthusiasm
- Celebrate their wins with them
- Be genuinely excited for them
- Share in their joy""",
            
            EmotionalTone.EMPATHETIC: """- The user is sharing something personal
- Show deep understanding and empathy
- Listen actively and ask thoughtful questions
- Be present and attentive
- Make them feel heard""",
            
            EmotionalTone.NEUTRAL: """- Maintain a warm, friendly tone
- Be conversational and natural
- Adapt to the user's emotional state
- Stay supportive and caring"""
        }
        
        return tone_map.get(tone, tone_map[EmotionalTone.NEUTRAL])
    
    def _get_mode_instructions(self, mode_context: Optional[str], is_grammar_mode: bool) -> str:
        """
        Returns mode-specific instructions for the persona.
        
        Args:
            mode_context: User's selected mode ("grammar", "chat", "vocabulary", etc.)
            is_grammar_mode: Legacy grammar mode flag
            
        Returns:
            Mode-specific instructions
        """
        if not mode_context:
            return ""
        
        mode_map = {
            "grammar": """GRAMMAR TUTOR MODE:
- You are in English tutor mode
- Gently correct any grammar mistakes while staying friendly
- Explain corrections in a supportive, encouraging way
- Don't be overly critical - focus on helping them improve
- Provide the corrected version and explain why""",
            
            "chat": """GENERAL CHAT MODE - CRITICAL INSTRUCTIONS:
- This is casual conversation mode - be like ChatGPT
- ABSOLUTELY NO grammar corrections or language teaching
- IGNORE any grammar mistakes completely
- Respond naturally to the CONTENT of their message only
- Be conversational, helpful, and engaging like a friend
- Answer questions, discuss topics, share thoughts
- Treat their English as perfectly fine regardless of errors
- Focus ONLY on what they're saying, never how they're saying it""",
            
            "vocabulary": """VOCABULARY LEARNING MODE:
- Focus on teaching new words and their meanings
- Provide examples, synonyms, and usage tips
- Help with pronunciation when asked
- Make vocabulary learning fun and engaging
- Use the words they're learning in your responses""",
            
            "dreams": """DREAM JOURNAL MODE:
- Provide thoughtful psychological interpretations
- Analyze symbols and themes in their dreams
- Be empathetic and insightful
- Help them understand possible meanings
- Ask follow-up questions about dream details""",
            
            "practice": """LANGUAGE PRACTICE MODE:
- Provide structured learning exercises
- Give grammar lessons with examples
- Help with pronunciation and usage
- Create practice scenarios and conversations
- Be encouraging and educational"""
        }
        
        return mode_map.get(mode_context, "")
    
    def _get_interface_formatting_instructions(self, interface: str) -> str:
        """
        Returns interface-specific formatting instructions.
        
        Args:
            interface: Interface type ("telegram", "whatsapp", "web")
            
        Returns:
            Interface-specific formatting instructions
        """
        if interface == "telegram":
            return """
TELEGRAM FORMATTING RULES - CRITICAL FOR READABILITY:
- ALWAYS put each numbered point on a new line
- Use this exact format for lists:

1. First point here

2. Second point here

3. Third point here

- Add blank lines between each numbered item
- For study/exam tips, use this structure:

ðŸ“š *Study Tips*

1. Point one with explanation

2. Point two with explanation

3. Point three with explanation

- Keep each point to 1-2 sentences maximum
- Use emojis (ðŸ“š ðŸ“ â° ðŸ’¡) to make sections clear
- NEVER write long paragraphs - break them up
- Put double line breaks between different sections
"""
        elif interface == "whatsapp":
            return """
WHATSAPP FORMATTING RULES - CRITICAL FOR MOBILE READABILITY:
- Keep responses SHORT and MOBILE-FRIENDLY
- Use this EXACT format for numbered lists:

ðŸ“š *Topic Title*

1. First Point Brief explanation in one sentence.

2. Second Point Another brief explanation.

3. Third Point Keep it concise and clear.

- Each numbered point should be ONE sentence maximum
- Put blank lines between each point
- Use emojis (ðŸ“š ðŸ“ â° ðŸ’¡) for section headers
- NEVER write long paragraphs
- Break information into digestible chunks
- Keep total response under 200 words for mobile
"""
        else:
            return """
WEB FORMATTING RULES:
- Use proper paragraphs and formatting
- Can be more detailed than mobile interfaces
- Use markdown formatting when appropriate
"""

    def _detect_emotional_tone(self, message: str) -> EmotionalTone:
        """
        Detects emotional tone from user message using keyword analysis.
        This is a simple heuristic-based approach.
        
        Args:
            message: User's message text
            
        Returns:
            Detected EmotionalTone
        """
        message_lower = message.lower()
        
        # Sad/stressed keywords
        sad_keywords = ["sad", "depressed", "stressed", "worried", "anxious", "upset", 
                       "crying", "hurt", "pain", "difficult", "hard", "struggling",
                       "tired", "exhausted", "overwhelmed"]
        
        # Happy/excited keywords
        happy_keywords = ["happy", "excited", "great", "amazing", "wonderful", "awesome",
                         "yay", "woohoo", "celebrate", "won", "success", "achieved",
                         "love", "fantastic", "excellent"]
        
        # Check for sad/stressed tone
        if any(keyword in message_lower for keyword in sad_keywords):
            return EmotionalTone.COMFORTING
        
        # Check for happy/excited tone
        if any(keyword in message_lower for keyword in happy_keywords):
            return EmotionalTone.CELEBRATORY
        
        # Check for questions or sharing (empathetic)
        if "?" in message or any(word in message_lower for word in ["tell you", "share", "happened"]):
            return EmotionalTone.EMPATHETIC
        
        # Default to neutral
        return EmotionalTone.NEUTRAL
    
    def _apply_ai_concealment(self, text: str) -> tuple[str, bool]:
        """
        Removes or replaces AI identity phrases from the response.
        
        Args:
            text: Generated response text
            
        Returns:
            Tuple of (concealed_text, was_modified)
        """
        original_text = text
        concealed_text = text
        
        # Apply each pattern
        for pattern in self.AI_IDENTITY_PATTERNS:
            # Remove the phrase entirely or replace with more natural language
            concealed_text = re.sub(
                pattern,
                "",
                concealed_text,
                flags=re.IGNORECASE
            )
        
        # Clean up any double spaces or awkward punctuation
        concealed_text = re.sub(r'\s+', ' ', concealed_text)
        concealed_text = re.sub(r'\s+([.,!?])', r'\1', concealed_text)
        concealed_text = concealed_text.strip()
        
        # Check if any modifications were made
        was_modified = (original_text != concealed_text)
        
        return concealed_text, was_modified
    
    def _format_for_whatsapp(self, text: str) -> str:
        """
        Format text specifically for WhatsApp mobile interface.
        Handles numbered lists, long paragraphs, and mobile readability.
        """
        # Handle numbered lists first - convert "1. Title Description" to proper format
        # Pattern: number + period + space + content until next number or end
        formatted_text = text
        
        # Find and format numbered items
        # Look for pattern: "1. Some text 2. More text" etc.
        numbered_pattern = r'(\d+)\.\s*([^0-9]*?)(?=\d+\.|$)'
        matches = re.findall(numbered_pattern, formatted_text, re.DOTALL)
        
        if matches:
            # Rebuild with proper formatting
            result = ""
            
            # Handle any text before the first numbered item
            first_match_start = formatted_text.find(f"{matches[0][0]}.")
            if first_match_start > 0:
                prefix = formatted_text[:first_match_start].strip()
                if prefix:
                    result += prefix + "\n\n"
            
            # Format each numbered item
            for i, (number, content) in enumerate(matches):
                content = content.strip()
                
                # Split content into title and description
                # Take first sentence as title, rest as description
                sentences = re.split(r'([.!?]+)', content)
                
                if len(sentences) >= 2:
                    title = sentences[0].strip()
                    description_parts = sentences[2:]  # Skip the punctuation
                    description = ''.join(description_parts).strip()
                    
                    result += f"*{number}. {title}*\n"
                    if description:
                        result += f"{description}\n\n"
                    else:
                        result += "\n"
                else:
                    # No clear title/description split
                    result += f"*{number}. {content}*\n\n"
            
            formatted_text = result.strip()
        else:
            # No numbered lists, just break up long paragraphs
            # Split into sentences and add line breaks for readability
            sentences = re.split(r'([.!?]+)', formatted_text)
            
            rebuilt_text = ""
            sentence_count = 0
            
            for i in range(0, len(sentences) - 1, 2):
                if i + 1 < len(sentences):
                    sentence = sentences[i].strip()
                    punctuation = sentences[i + 1] if i + 1 < len(sentences) else ""
                    
                    if sentence:
                        rebuilt_text += sentence + punctuation
                        sentence_count += 1
                        
                        # Add line break after every sentence for mobile readability
                        if sentence_count % 1 == 0:  # Every sentence gets a line break
                            rebuilt_text += "\n\n"
            
            formatted_text = rebuilt_text.strip()
        
        # Handle emoji headers - add proper spacing
        formatted_text = re.sub(
            r'([ðŸ“šðŸ“â°ðŸ’¡ðŸŽ¯âœ¨])\s*([A-Z][^ðŸ“šðŸ“â°ðŸ’¡ðŸŽ¯âœ¨]*?)(\d+\.|\n|$)',
            r'\1 *\2*\n\n\3',
            formatted_text
        )
        
        # Clean up multiple consecutive line breaks (max 2)
        formatted_text = re.sub(r'\n{3,}', '\n\n', formatted_text)
        
        # Clean up extra spaces
        formatted_text = re.sub(r'[ \t]+', ' ', formatted_text)
        
        return formatted_text.strip()

    def _apply_interface_formatting(self, text: str, interface: str) -> str:
        """
        Apply interface-specific formatting to the response.
        
        Args:
            text: Response text to format
            interface: Interface type ("telegram", "whatsapp", "web")
            
        Returns:
            Formatted text for the specific interface
        """
        if interface == "telegram":
            # Clean up Telegram formatting for better readability
            formatted_text = text
            
            # Add proper line breaks before numbered items
            formatted_text = re.sub(r'([.!?])\s*(\d+\.)', r'\1\n\n\2', formatted_text)
            
            # Ensure each numbered item ends with double line break
            formatted_text = re.sub(r'(\d+\.\s*\*\*[^*]+\*\*:[^0-9]+?)(\d+\.)', r'\1\n\n\2', formatted_text)
            
            # Add line breaks after sentences that end numbered items
            formatted_text = re.sub(r'([.!?])\s*(\d+\.)', r'\1\n\n\2', formatted_text)
            
            # Clean up multiple consecutive line breaks (max 2)
            formatted_text = re.sub(r'\n{3,}', '\n\n', formatted_text)
            
            # Clean up extra spaces
            formatted_text = re.sub(r'[ \t]+', ' ', formatted_text)
            
            # Ensure proper spacing around emojis
            formatted_text = re.sub(r'([ðŸ“šðŸ“â°ðŸ’¡ðŸŽ¯âœ¨])\s*([*A-Z])', r'\1 \2', formatted_text)
            
            # Add line break after emoji headers
            formatted_text = re.sub(r'([ðŸ“šðŸ“â°ðŸ’¡ðŸŽ¯âœ¨]\s*\*[^*]+\*)\s*(\d+\.)', r'\1\n\n\2', formatted_text)
            
            return formatted_text.strip()
        
        elif interface == "whatsapp":
            # WhatsApp-specific formatting for mobile readability
            return self._format_for_whatsapp(text)
        
        return text

    async def generate_response(self, context: ConversationContext) -> PersonaResponse:
        """
        Generates a persona-aware response using the LLM.
        
        Args:
            context: ConversationContext with all necessary information
            
        Returns:
            PersonaResponse with generated content and metadata
        """
        # Auto-detect emotional tone if not provided
        if context.emotional_tone == EmotionalTone.NEUTRAL:
            context.emotional_tone = self._detect_emotional_tone(context.user_message)
        
        # Create the persona prompt
        system_prompt = self._create_persona_prompt(context)
        
        try:
            # Check rate limit before making API call
            self.rate_limiter.check_and_increment(GroqModel.LLAMA_8B)
            
            # Call Groq API
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": system_prompt
                    },
                    {
                        "role": "user",
                        "content": context.user_message
                    }
                ],
                temperature=0.8,  # Higher temperature for more natural, varied responses
                max_tokens=500,
                top_p=0.9
            )
            
            # Extract response content
            raw_content = response.choices[0].message.content
            
            # Apply AI identity concealment
            concealed_content, was_concealed = self._apply_ai_concealment(raw_content)
            
            # Apply interface-specific formatting
            formatted_content = self._apply_interface_formatting(concealed_content, context.interface)
            
            return PersonaResponse(
                content=formatted_content,
                language=context.language,
                emotional_tone=context.emotional_tone,
                concealment_applied=was_concealed
            )
            
        except RateLimitExceededError:
            # Re-raise rate limit errors
            raise
        except Exception as e:
            # Return a friendly fallback response
            fallback_message = "I'm here for you! Could you tell me more about that?"
            return PersonaResponse(
                content=fallback_message,
                language=context.language,
                emotional_tone=context.emotional_tone,
                concealment_applied=False
            )
    
    async def generate_streaming_response(
        self,
        context: ConversationContext
    ) -> Any:
        """
        Generates a streaming persona-aware response for real-time voice conversations.
        
        Args:
            context: ConversationContext with all necessary information
            
        Yields:
            Chunks of response text as they're generated
        """
        # Auto-detect emotional tone if not provided
        if context.emotional_tone == EmotionalTone.NEUTRAL:
            context.emotional_tone = self._detect_emotional_tone(context.user_message)
        
        # Create the persona prompt
        system_prompt = self._create_persona_prompt(context)
        
        try:
            # Check rate limit before making API call
            self.rate_limiter.check_and_increment(GroqModel.LLAMA_8B)
            
            # Call Groq API with streaming
            stream = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "system",
                        "content": system_prompt
                    },
                    {
                        "role": "user",
                        "content": context.user_message
                    }
                ],
                temperature=0.8,
                max_tokens=500,
                top_p=0.9,
                stream=True
            )
            
            # Accumulate text for AI concealment
            accumulated_text = ""
            
            async for chunk in stream:
                if chunk.choices[0].delta.content:
                    text_chunk = chunk.choices[0].delta.content
                    accumulated_text += text_chunk
                    yield text_chunk
            
            # Note: AI concealment is applied to accumulated text
            # In streaming mode, we yield raw chunks for low latency
            # Post-processing can be done on the client side if needed
            
        except RateLimitExceededError:
            # Re-raise rate limit errors
            raise
        except Exception as e:
            yield "I'm here for you! Could you tell me more about that?"
